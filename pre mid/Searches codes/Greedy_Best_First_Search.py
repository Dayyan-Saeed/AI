# -*- coding: utf-8 -*-
"""Untitled23.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oonOyqRfhx2LD_C2VFp-B_Nrp2WFtM6_
"""

MyGraph = {
    'S' : {'A':3,'B':2},
    'A' : {'C':4,'D':1},
    'C' : {},
    'D' : {},
    'B' : {'E':3,'F':1},
    'E' : {'H':5},
    'H' : {},
    'F' : {'I':2,'G':3},
    'I' : {},
    'G' : {}
}
HeuristicValues = {
    'A':12,
    'B':4,
    'C':7,
    'D':3,
    'E':8,
    'F':2,
    'H':4,
    'I':9,
    'S':13,
    'G':0
}
StartNode='S'
GoalNode='G'

def BFS():
    Path=[StartNode]
    Cost=0
    Queue, Visited = [Cost,StartNode],[]
    while Queue:
        minHeuristicIndex=0
        i=0;
        while i<len(Queue):
          # Queue[minHeuristicIndex+1] and Queue[i+1] are used to access the nodes in the Queue list. Since each node is represented as a string and is followed by its cost in the Queue list, adding 1 to the index (minHeuristicIndex or i) allows us to access the node itself (not its cost).
          # len(Queue[minHeuristicIndex+1])-1 and len(Queue[i+1])-1 are used to find the index of the last character in each node's name. This assumes that the last character of each node's name is a unique identifier for that node. For example, if a node is named 'A', the last character 'A' will be used as its identifier.
          # Queue[minHeuristicIndex+1][len(Queue[minHeuristicIndex+1])-1] and Queue[i+1][len(Queue[i+1])-1] extract the last character (node identifier) of the nodes at index minHeuristicIndex and i, respectively.
          # HeuristicValues[Queue[minHeuristicIndex+1][len(Queue[minHeuristicIndex+1])-1]] and HeuristicValues[Queue[i+1][len(Queue[i+1])-1]] retrieve the heuristic values corresponding to the nodes identified in step 3.
            if HeuristicValues[Queue[minHeuristicIndex+1][len(Queue[minHeuristicIndex+1])-1]] > HeuristicValues[Queue[i+1][len(Queue[i+1])-1]]:
                minHeuristicIndex=i
            i=i+2

        Cost=Queue.pop(minHeuristicIndex)
        Path=Queue.pop(minHeuristicIndex)
        Last=Path[len(Path)-1]

        if Last==GoalNode:
            Path.append("Total Cost: "+str(Cost))
            return Path

        if Last not in Visited:
            Visited.append(Last)

            for i in MyGraph[Last].keys():
                NewPath=list(Path)
                NewPath.append(i)
                Queue.append(Cost+MyGraph[Last][i])
                Queue.append(NewPath)


print(BFS())